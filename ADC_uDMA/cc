#include <stdbool.h>
#include <stdint.h>

#include "inc/hw_ints.h"
#include "inc/hw_memmap.h"
#include "inc/hw_adc.h"
#include "inc/hw_types.h"
#include "inc/hw_udma.h"
#include "inc/hw_emac.h"
#include "driverlib/debug.h"
#include "driverlib/gpio.h"
#include "driverlib/interrupt.h"
#include "driverlib/pin_map.h"
#include "driverlib/sysctl.h"
#include "driverlib/uart.h"
#include "driverlib/adc.h"
#include "driverlib/udma.h"
#include "driverlib/emac.h"
#include "driverlib/timer.h"
#include "driverlib/rom.h"



#define ADC_SAMPLE_BUF_SIZE     256

#pragma DATA_ALIGN(ucControlTable, 1024)
uint8_t ucControlTable[1024];

static uint16_t ADC_OUT[ADC_SAMPLE_BUF_SIZE];
static bool _sampling;
static uint8_t g_ui8ADC_DMA_Sample_Stop;
static uint8_t g_ucDataReady;
static uint16_t _samples;
bool init_ADC_DMA_SampleTimer(void);
bool state;
uint32_t n=0;
static uint32_t g_ui32SysTickCount;
bool DMA_Sample_Start(uint16_t);

void SysTick_Handler(void)
{
    //
    // Update our system tick counter.
    //
    g_ui32SysTickCount++;
}


int main(void)
{

    SysCtlClockSet(SYSCTL_SYSDIV_2_5|SYSCTL_USE_PLL|SYSCTL_OSC_MAIN|SYSCTL_XTAL_16MHZ);

    SysCtlDelay(20);
	
	  ROM_SysTickPeriodSet(SysCtlClockGet() / 1000000 - 1); //Sets the period of the SysTic counter to 1us 
    ROM_SysTickIntEnable();
    ROM_SysTickEnable();

    init_ADC_DMA_SampleTimer();


	
    while(1)
		{
			state = DMA_Sample_Start(2);
			while (g_ucDataReady == 0);
			if (g_ucDataReady)
			{
				//Process_Your_Data();
			}

		}

}

bool init_ADC_DMA_SampleTimer(void){
    ////////////// Peripheral Init //////////////////
    // This is good practice; never assume that a complete system reset was done between debugging sessions.

    // Disable, Reset, and Enable uDMA and then wait for the peripheral to be ready for access.
    ROM_SysCtlPeripheralDisable(SYSCTL_PERIPH_UDMA);
    ROM_SysCtlPeripheralReset(SYSCTL_PERIPH_UDMA);
    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_UDMA);
    while(!(ROM_SysCtlPeripheralReady(SYSCTL_PERIPH_UDMA)));

    // Disable, Reset, and Enable ADC0 and then wait for the peripheral to be ready for access.
    ROM_SysCtlPeripheralDisable(SYSCTL_PERIPH_ADC0);
    ROM_SysCtlPeripheralReset(SYSCTL_PERIPH_ADC0);
    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_ADC0);
    while(!(ROM_SysCtlPeripheralReady(SYSCTL_PERIPH_ADC0)));

    // Disable, Reset, and Enable Timer 0A and then wait for the peripheral to be ready for access.
    ROM_SysCtlPeripheralDisable(SYSCTL_PERIPH_TIMER0);
    ROM_SysCtlPeripheralReset(SYSCTL_PERIPH_TIMER0);
    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_TIMER0);
    while(!(ROM_SysCtlPeripheralReady(SYSCTL_PERIPH_TIMER0)));

    // Disable, Reset, and Enable GPIO Port E and then wait for the peripheral to be ready for access.
    // We want to sample ADC from Pin PE_3
    ROM_SysCtlPeripheralDisable(SYSCTL_PERIPH_GPIOE);
    ROM_SysCtlPeripheralReset(SYSCTL_PERIPH_GPIOE);
    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOE);
    while(!(ROM_SysCtlPeripheralReady(SYSCTL_PERIPH_GPIOE)));

    /////////////////////////////////////////////////
    ////////////// uDMA Init ////////////////////////

    //Enables the uDMA controller for use.
    ROM_uDMAEnable();

    // Set uDMA Control Table Address
    ROM_uDMAControlBaseSet(ucControlTable);

    // Assign the channel 17 for ADC0 Sequencer 3 for ADC IN
    ROM_uDMAChannelAssign(UDMA_CHANNEL_ADC0);

    // Put the attributes in a known state.  These should already be disabled by default.
    ROM_uDMAChannelAttributeDisable(UDMA_CHANNEL_ADC0, UDMA_ATTR_ALTSELECT | UDMA_ATTR_HIGH_PRIORITY | UDMA_ATTR_REQMASK);

    // Set the USEBURST attribute. This is somewhat more efficient bus usage than the default which allows single or burst transfers.
    ROM_uDMAChannelAttributeEnable(UDMA_CHANNEL_ADC0, UDMA_ATTR_USEBURST);

    // Configure the control parameters for the primary control structure for DMA.
    // ADC FIFO (Src) DOES NOT INCREMENT, YA BUFFOON! Arbitration size: 1
    ROM_uDMAChannelControlSet(UDMA_CHANNEL_ADC0 | UDMA_PRI_SELECT,
    UDMA_SIZE_16 | UDMA_SRC_INC_NONE | UDMA_DST_INC_16 | UDMA_NEXT_USEBURST |
    UDMA_ARB_1);


    // Set up the transfer parameters for the primary control structure.
    // The mode is set to Ping-Pong, TransferSize: 1024
    uDMAChannelTransferSet(UDMA_CHANNEL_ADC0 | UDMA_PRI_SELECT,
                           UDMA_MODE_BASIC,
                           (void *) (ADC0_BASE + ADC_O_SSFIFO0),
                           &ADC_OUT,
                           ADC_SAMPLE_BUF_SIZE);

    // This function enables a specific uDMA channel for use.  This function must be used to enable a channel before it can be used to perform a uDMA transfer.
    // When a uDMA transfer is completed, the channel is automatically disabled by the uDMA controller.  Therefore, this function should be called prior to
    // starting up any new transfer.
    ROM_uDMAChannelEnable(UDMA_CHANNEL_ADC0);

    /////////////////////////////////////////////////
    ////////////// ADC0SS0 Init /////////////////////

    // Configure the analog ADC function for Pin PE_2.
    ROM_GPIOPinTypeADC(GPIO_PORTE_BASE, GPIO_PIN_2);

    // Configure the ADC to use PLL at 480 MHz divided by 15 to get the maximum ADC clock of 32 MHz. This gives 1MSPS Maximum Sampling Rate?
    ADCClockConfigSet(ADC0_BASE, ADC_CLOCK_SRC_PIOSC | ADC_CLOCK_RATE_FULL, 1);

    // Set External ADC Reference (VREFA+). BE AWARE TO SET TO INTERNAL IF YOU HAVE NO EXTERNAL REFERENCE!
    ROM_ADCReferenceSet(ADC0_BASE,ADC_REF_INT);

    // Good practice to disable the sequence before configuring it
    ROM_ADCSequenceDisable(ADC0_BASE, 0);

    // Configure ADC to be triggered from Timer
    ROM_ADCSequenceConfigure(ADC0_BASE, 0, ADC_TRIGGER_TIMER, 0 /*Priority*/);

    // Configure steps on sequence.  Sample channels in single-ended mode (default) and configure the interrupt flag after last conversion
    ROM_ADCSequenceStepConfigure(ADC0_BASE,0,0,ADC_CTL_CH1| ADC_CTL_END | ADC_CTL_IE);

    // Enable ADC Sequence 0 Interrupt on the interrupt controller (NVIC).
    ROM_IntEnable(INT_ADC0SS0);

    // This function enables the indicated ADC interrupt sources.  Only the sources that are enabled can be reflected to the processor interrupt;
    // disabled sources have no effect on the processor.
    ADCIntEnableEx(ADC0_BASE, ADC_INT_DMA_SS0);

    // Since ADC0 sample sequence 3 is now configured, it must be enabled.
    ROM_ADCSequenceEnable(ADC0_BASE, 0);

    /////////////////////////////////////////////////
    ////////////// Timer0A Init /////////////////////

    // Configure Timer0 to be Periodic
    ROM_TimerConfigure(TIMER0_BASE, TIMER_CFG_PERIODIC);

    // Load Timer0_A with Sampling Freq. interrupt speed.
    // We do (SamplingFreq. - 1) because the timer fires on zero.
    ROM_TimerLoadSet(TIMER0_BASE, TIMER_A, 4999);

    // Enable Timer 0 to trigger ADC0SS3 when it's load value is met
    TimerControlTrigger(TIMER0_BASE, TIMER_A, true);

    // Enable the Timer events that can cause an ADC trigger event.
    TimerADCEventSet(TIMER0_BASE, TIMER_ADC_TIMEOUT_A);

    return 1;
}


bool DMA_Sample_Start(uint16_t samples){
    if (_sampling)
        return true;

    // Initialize the Sample Stop Sequence flag
    g_ui8ADC_DMA_Sample_Stop = 0;

    // Reset g_ucDataReady flag so next Main() loop doesn't re-use old ADC data
    g_ucDataReady = 0;

    _sampling = true;

    // Set samples
    _samples = samples;

    // Un-Pend ADC0SS0's Interrupt from the interrupt controller, just in case.
    ROM_IntPendClear(INT_ADC0SS0);

    // Load Timer0_A with Sampling Freq. interrupt speed
    ROM_TimerLoadSet(TIMER0_BASE, TIMER_A, 4999);

    // Enable Timer 0 to trigger ADC0SS3 when it's load value is met.
    TimerControlTrigger(TIMER0_BASE, TIMER_A, true);

    // Enable the Timer events that can cause an ADC trigger event.
    TimerADCEventSet(TIMER0_BASE, TIMER_ADC_TIMEOUT_A);

    ROM_uDMAChannelDisable(UDMA_CHANNEL_ADC0);


    ROM_uDMAChannelTransferSet(UDMA_CHANNEL_ADC0 | UDMA_PRI_SELECT,
    UDMA_MODE_BASIC,
                               (void *) (ADC0_BASE + ADC_O_SSFIFO0),
                               &ADC_OUT,
                               ADC_SAMPLE_BUF_SIZE);

    // Enable the ADC0 Sequence 3 channel for ADC IN.
    ROM_uDMAChannelEnable(UDMA_CHANNEL_ADC0);

    // Enable ADC Sequence 0 Interrupt on the interrupt controller (NVIC).
    ROM_IntEnable(INT_ADC0SS0);

    // This function enables the indicated ADC interrupt sources.
    // Only the sources that are enabled can be reflected to the processor interrupt;
    // disabled sources have no effect on the processor.
    ADCIntEnableEx(ADC0_BASE, ADC_INT_DMA_SS0);

    // Enables DMA requests to be generated based on the FIFO level of ADC0 sample sequencer 0.
    ADCSequenceDMAEnable(ADC0_BASE, 0);

    // Enable the ADC Sequencer to sample on Timer Trigger
    ROM_ADCSequenceEnable(ADC0_BASE, 0);

    // Enable Timer0_A to sample ADC!!! THIS SHOULD START ADC SAMPLING
    ROM_TimerEnable(TIMER0_BASE, TIMER_A);

    return true;
}

void ADC0SS0_Handler()
{

		ROM_ADCIntClear(ADC0_BASE, 0);

		ADCIntClearEx(ADC0_BASE, ADC_INT_DMA_SS0);

		volatile uint32_t ui32Mode;
	n++;
		ui32Mode = ROM_uDMAChannelModeGet(UDMA_CHANNEL_ADC0| UDMA_PRI_SELECT);
		ROM_TimerDisable(TIMER0_BASE, TIMER_A);

		ROM_TimerIntClear(TIMER0_BASE, TIMER_TIMA_TIMEOUT);

		ROM_IntPendClear(INT_ADC0SS0);

		// DISABLE DMA requests from being generated based on the FIFO level of ADC0 sample sequencer 3.
		ADCSequenceDMADisable(ADC0_BASE, 0);

		// Get the Interrupt Status so we can clear it. Otherwise, we'll end up back in this interrupt handler
		uint32_t ui32ADCIntStatusEx = ADCIntStatusEx(ADC0_BASE, false); // Not Masked
		ADCIntClearEx(ADC0_BASE, ui32ADCIntStatusEx);

		// Reset the DMA Increment count
		//ui16inc = 0;

		_sampling = 0;

		// Signal that we have new data to be processed
		g_ucDataReady = 1;
			


}